# Author: Chenchen

# 树的概念
# 数的度，深度，节点
# 二叉树，度为2的树
# 满二叉树，当存在孩子节点时，左右两个孩子节点都存在的二叉树叫满二叉树，
# 完全二叉树，从满二叉树的后面去掉孩子节点，只能从后面往前去
# 堆，有大根堆和小根堆，是一种特殊的完全二叉树，大根堆的父节点值均比孩子节点要大，小根堆相反，根值均比孩子节点的值要小

# 堆的特性，如果左右孩子节点的树都是一个堆，但自身不是堆时，可以通过一次向下的调整(大的值往根上升，)，变成一个堆

#堆排序过程：
# 1. 建立堆，从最后一个孩子点和他的父节点开始调整，保证父节点均比孩子节点要大，依次从后往前，从小往上调整，最终将得到一个堆
# 2. 得到堆顶元素，为最大元素
# 3. 去掉堆顶，将堆最后一个元素放到堆顶，此时可以通过一次调整让堆重新有序
# 4. 堆顶元素为第二大元素
# 5. 重复步骤3，直到堆变空

import random

def shift(li, low, high):
  """
  调整函数，非常关键，建堆和排序的时候都要用到，用来将一个左右孩子均为一个堆，但加上父节点之后就不为堆的二叉树变成一个堆。
  过程为：首先判断是否有左孩子，再判断是否有右孩子，找到左右孩子中最大的一个并和父亲比较，如果父还值小，则大的孩子替换掉父亲
        再向下走，将大的孩子变成父亲，依次类推，最后再讲刚开始保留的父亲的值复制给最后的那个“父亲”
  :param li:
  :param low:  左下标
  :param high: 右下标
  :return:
  """
  i = low  #根节点
  j = 2 * i + 1  #左孩子节点
  tmp = li[i]
  while j <= high:    #左孩子节点还在树的范围之内
    if j < high and li[j] < li[j+1]:    # j<high 说明还有右孩子节点，判断左孩子节点是否比右孩子节点要大，如果比右孩子小，这将j变为右孩子节点
      j += 1    #现在的j为大的右孩子节点
    if tmp < li[j]:  #父节点小于最大的孩子节点，如果为真语句的执行结果就是将孩子节点上位，如果发生了调整，需要继续向下判断
      li[i] = li[j]  #大的孩子节点替换掉父节点
      i = j
      j = 2 * i + 1
    else:   #如果不发生调整，说明根节点要比左右孩子几点都要大，而孩子节点已经是堆了，所以调整就已经结束了
      break
  li[i] = tmp


def heap_sort(li):
  """
  排序过程
  :param li:
  :return:
  """
  n = len(li)
  # 开始建堆，从后往前看，首先找到最后一个孩子(n-1)和他的父亲(n//2-1)的下标,不管列表是奇数还是偶数个，最后一个孩子的父亲总是(n//2-1)
  for i in range(n // 2 -1, -1, -1):    #从最后一个父亲节点开始往前推，能保证除了根节点外左右孩子节点均为堆
    shift(li, i, n - 1)
  # 堆建完了，挨个出数
  for i in range(n - 1, -1, -1):     #从最后一个数开始和根节点调换，这样又变成了根节点最小，但左右孩子树均为堆的情况
    li[0], li[i] = li[i], li[0]    #互换
    shift(li, 0, i-1)  #这个时候列表的最后一个数已经被替换成最大的那个根节点了，也就是列表里面的最大数，新的调整可以剔除最后一个数，


def merge(li, low, mid, high):
  """
  性质：如果一个列表分成两半有序，那么可以通过一次归并让整个列表变得有序
  需要两个指针，刚开始分别指向两个有序列表的最左边，然后依次进行比较，将小的那个数放到临时列表。需要两个循环，第一个循环用来将
  左右两边以位数最少的那边进行排序，循环完列表只剩下一边
  :param li:
  :param low:
  :param mid:
  :param high:
  :return:
  """
  i = low
  j = mid +1
  li_tmp = []
  while i<= mid and j<=high:  #循环后后列表将只剩下一半的有序列表
    if li[i] < li[j]:
      li_tmp.append(li[i])
      i +=1
    else:
      li_tmp.append(li[j])
      j +=1
  while i<=mid:  #这个循环和下面那个循环到时候只会执行一个
    li_tmp.append(li[i])
    i +=1
  while j<=high:
    li_tmp.append(li[j])
    j +=1
  li[low:high+1] = li_tmp
  # print(li_tmp)

def merge_sort(li, low, high):
  if low < high:
    mid = (low + high)//2
    merge_sort(li, low, mid)
    merge_sort(li, mid + 1, high)
    merge(li, low, mid, high)


a = list(range(1000000))
# a = [4,5,7,8,1,2,3,9]
# random.shuffle(a)
# print(a)
merge_sort(a, 0, len(a)-1)
print(a)



